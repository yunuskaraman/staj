import"reflect-metadata";import{__decorate as e,__param as r,__metadata as t}from"tslib";import{scoped as s,Lifecycle as o,inject as i,injectable as n,container as a}from"tsyringe";import*as c from"path";import{dirname as l}from"path";import*as m from"fs";import{extract as p}from"tar-fs";import{createBrotliDecompress as u}from"zlib";import{spawn as h}from"child_process";import{fileURLToPath as d}from"url";function f(){return e=>(s(o.ContainerScoped)(e),e)}const v=Symbol("Current root dir"),b=Symbol("Filesystem"),y=Symbol("Brotli decompress method"),g=Symbol("Tar decompress method"),S=Symbol("Libre office executable path"),C=Symbol("Libre office compressed file path"),x=Symbol("Child process spawner"),P=Symbol("Libre office arguments");let w=class{constructor(e){this.spawn=e}execute(e,r){return this.spawn(`${e}`,r)}};w=e([f(),r(0,i(x)),t("design:paramtypes",[Function])],w);let k=class{constructor(e){this.fs=e}exists(e){return new Promise((r=>{this.fs.stat(e,(e=>{e&&r(!1),r(!0)}))}))}createReadableStream(e){return this.fs.createReadStream(e)}createWritableStream(e){return this.fs.createWriteStream(e)}};k=e([f(),r(0,i(b)),t("design:paramtypes",[Object])],k);let E=class{constructor(e){this.decompress=e}getConverter(e){return this.decompress(e)}};E=e([f(),r(0,i(g)),t("design:paramtypes",[Function])],E);let V=class{constructor(e){this.decompressMethod=e}getConverter(){return this.decompressMethod()}};V=e([f(),r(0,i(y)),t("design:paramtypes",[Function])],V);let D=class{constructor(e,r,t){this.fileSystemService=e,this.brotliConverter=r,this.tarDecompressorConverter=t}async decompress(e,r){return new Promise(((t,s)=>{const o=this.fileSystemService.createReadableStream(e).pipe(this.brotliConverter.getConverter()).pipe(this.tarDecompressorConverter.getConverter(r));o.on("finish",(()=>t(r))),o.on("error",(e=>s(e)))}))}};D=e([f(),t("design:paramtypes",[k,V,E])],D);let O=class{constructor(e,r,t,s,o){this.loDecompressor=e,this.fileSystemService=r,this.currentDir=t,this.loExecutablePath=s,this.loCompressedPath=o}async getExecutablePath(){return await this.prepareBinary(),this.loExecutablePath}async prepareBinary(){await this.fileSystemService.exists(this.loExecutablePath)||await this.loDecompressor.decompress(this.loCompressedPath,this.currentDir)}};O=e([f(),r(2,i(v)),r(3,i(S)),r(4,i(C)),t("design:paramtypes",[D,k,String,String,String])],O);let R=class{constructor(e,r,t){this.loExecutableGetter=e,this.commandExecuter=r,this.libreOfficeArgs=t}async convertToPdf(e,r){const t=c.resolve(e),s=c.resolve(r),o=await this.loExecutableGetter.getExecutablePath(),i=(e=>[...e.matchAll(/(.*\/)*([ \w-]+\.pdf)/gm)][0])(s),n=!!i[1]&&i[1].slice(0,-1)||"/temp",a=i[2];await this.runConvertingProcess(o,t,n,a)}runConvertingProcess(e,r,t,s){return new Promise(((o,i)=>{const n=this.commandExecuter.execute(e,[...this.libreOfficeArgs,"--convert-to",`${s}`,"--outdir",`${t}`,`${r}`]);n.on("close",(e=>{o(e)})),n.on("error",(e=>{i(e)}))}))}};R=e([f(),r(2,i(P)),t("design:paramtypes",[O,w,Array])],R);let T=class{constructor(e){this.libreOfficeRunner=e}async convert(e,r){return await this.libreOfficeRunner.convertToPdf(e,r),!0}};T=e([n(),t("design:paramtypes",[R])],T);const j=a.createChildContainer(),A=l(d(import.meta.url));[{token:v,provider:{useValue:c.join(A,"./")}},{token:b,provider:{useValue:m}},{token:g,provider:{useValue:p}},{token:y,provider:{useValue:u}},{token:S,provider:{useValue:c.join(A,"./instdir/program/soffice")}},{token:C,provider:{useValue:c.join(A,"./bin/lo.tar.br")}},{token:x,provider:{useValue:h}},{token:P,provider:{useValue:["--headless","--invisible","--nodefault","--view","--nolockcheck","--nologo","--norestore"]}}].forEach((e=>j.register(e.token,e.provider)));class F{constructor(){this.docxToPdfConverter=j.resolve(T)}convert(e,r){return this.docxToPdfConverter.convert(e,r)}}export{F as Converter};
